[{"path":"/articles/errorlocate.html","id":"intro","dir":"Articles","previous_headings":"","what":"Intro","title":"Find errors in data","text":"Errorlocate uses validation rules package validate locate faulty values observations (database slang: erronenous fields records). follows simple recipe (Felligi-Holt): Check record valid (using supplied validation rules) valid adjust minimum number values make valid. errorlocate translating validation rules record values mixed integer problem (see vignette(\"inspect_mip\", package=\"errorlocate\") solving using R package lpSolveAPI.","code":""},{"path":"/articles/errorlocate.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Find errors in data","text":"Locating errors part data cleaning workflow, see e.g. Loo Jonge (2018), locating errors, errors removed (set NA) subsequently imputed. input errorlocate validation rules, can formulated using package validate (van der Loo de Jonge 2019). typical workflow using errorlocate : Formulate validation rules using validate::validator() Check records invalid using validate::confront() Use validate::summary() get overview invalid records rules violate. (Optional) Correct obvious data errors correction rules, example using dcmodify::modify (Optional) Determine weights variables, indicating likely faulty. Higher weights indicate trust variable. Use locate_errors find values faulty invalid records. Use replace_errors set faulty values NA. Use deductive imputation fill missing values follow rules, e.g. deductive::deduImpute() Impute remaining missing values using favorite imputation method, e.g. simputation (Optional) Re-validate data using validate::confront() check records now valid. Post hoc: Analyze output locate_errors get insights variables often faulty others, can used improve future data collection processes.","code":""},{"path":"/articles/errorlocate.html","id":"main-methods","dir":"Articles","previous_headings":"","what":"Main methods","title":"Find errors in data","text":"errorlocate two main functions used: locate_errors detecting errors replace_errors replacing faulty values NA Let’s start simple example: rule age negative: following data set summary(le) gives overview errors found data set. complete error listing can found : says record 1 faulty value age. Suppose expand rules validate::confront can see rule r2 violated (record 2). errors found locate_errors? now detects age observation 2 also faulty, since violates second rule. Note use set.seed. needed example, either age income can considered faulty. set.seed assures procedure reproducible. replace_errors can remove errors (still need imputed). replace_errors set faulty values NA.","code":"library(validate) library(errorlocate) rules <- validator(age > 0) \"age, income  -10,    0     15, 2000   25, 3000   NA, 1000 \" -> csv d <- read.csv(textConnection(csv), strip.white = TRUE) #>   age income #> 1 -10      0 #> 2  15   2000 #> 3  25   3000 #> 4  NA   1000 le <- locate_errors(d, rules) summary(le) #> Variable: #>     name errors missing #> 1    age      1       1 #> 2 income      0       0 #> Errors per record: #>   errors records #> 1      0       3 #> 2      1       1 le$errors #>        age income #> [1,]  TRUE  FALSE #> [2,] FALSE  FALSE #> [3,] FALSE  FALSE #> [4,]    NA  FALSE rules <- validator( r1 = age > 0                   , r2 = if (income > 0) age > 16                   ) d |>    confront(rules) |>    summary() #>   name items passes fails nNA error warning               expression #> 1   r1     4      2     1   1 FALSE   FALSE                  age > 0 #> 2   r2     4      2     1   1 FALSE   FALSE income <= 0 | (age > 16) set.seed(1) le <- locate_errors(d, rules) le$errors #>        age income #> [1,]  TRUE  FALSE #> [2,]  TRUE  FALSE #> [3,] FALSE  FALSE #> [4,]    NA  FALSE d_fixed <- replace_errors(d, le) d_fixed |> confront(rules) |>summary() #>   name items passes fails nNA error warning               expression #> 1   r1     4      1     0   3 FALSE   FALSE                  age > 0 #> 2   r2     4      2     0   2 FALSE   FALSE income <= 0 | (age > 16) d_fixed #>   age income #> 1  NA      0 #> 2  NA   2000 #> 3  25   3000 #> 4  NA   1000"},{"path":"/articles/errorlocate.html","id":"weights","dir":"Articles","previous_headings":"Main methods","what":"Weights","title":"Find errors in data","text":"locate_errors allows supplying weights variables. common quality observed variables differs. trust age retrieved official population register, can give weight chooses income decide two (record 2): Weights can specified different ways: (see also errorlocate::expand_weights): specifying: variables weight 1 named vector: records set weights. Unspecified columns weight 1. named matrix data.frame, dimension data: specify weights per record. Use Inf weights fixate variable, won’t changed.","code":"set.seed(1) # good practice, see later in this document weight <- c(age = 2, income = 1)  le <- locate_errors(d, rules, weight) le$errors #>        age income #> [1,]  TRUE  FALSE #> [2,] FALSE   TRUE #> [3,] FALSE  FALSE #> [4,]    NA  FALSE"},{"path":"/articles/errorlocate.html","id":"reproducability-set-seed","dir":"Articles","previous_headings":"","what":"Reproducability (set.seed)","title":"Find errors in data","text":"error location procedure can , cases, multiple optimal solutions. example given rule: (married == TRUE) age > 16 following data: either age married can considered faulty. weights specified, locate_errors randomly choose one two. adding internally small amount random noise weights. make sure results reproducible, good practice use set.seed calling locate_errors. Note using set.seed makes exact indentical input reproducible. Whenever input data.frame different order, different number rows columns, generated noise weights records different. level reproducibility can achieved generating noise beforehand using errorlocate::add_noise, storing weights together records supplying noisy weights locate_errors.","code":"#>   age married #> 1   4    TRUE"},{"path":"/articles/errorlocate.html","id":"performance-parallelisation","dir":"Articles","previous_headings":"","what":"Performance / Parallelisation","title":"Find errors in data","text":"locate_errors solves mixed integer problem. number interactions validation rules large, finding optimal solution can become computationally intensive. locate_errors well replace_errors parallization option: Ncpus making use multiple processors. $duration (s) property solution indicates time spent find solution record. can restricted using argument timeout (s).","code":"# restrict time per record to max 30 seconds le <- locate_errors(d, rules, timeout=30) # duration is in seconds. le$duration #> [1] 0.002124786 0.001615286 0.000000000 0.001486301"},{"path":"/articles/inspect_mip.html","id":"intro","dir":"Articles","previous_headings":"","what":"Intro","title":"Inspecting the errorlocate Mixed Integer Program","text":"Errorlocate uses linear, categorical conditional rules rules set formulated R package validate, create Mixed Integer Problem. users details translation relevant hidden locate_errors. Often number errors found processing time much relevant parameters. cases, may run problems error localization problem: processing time (records) locate_errors high. locate_errors missed obvious error. locate_errors indicates find valid solution (records) . Problem . can addressed using parallel argument locate_errors (replace_errors). Problem b can due error_locate ignores non-linear rules, therefore able deduce errors, takes linear, categorical conditional rules account. may also problems rules set. Problems set may mitigated using validatetools package can detect conflicting redundant rules methods simplify rule set. want dive deep mixed integer problem created error_locate can use inspect_mip function.","code":""},{"path":"/articles/inspect_mip.html","id":"a-bit-of-theory","dir":"Articles","previous_headings":"","what":"A bit of theory","title":"Inspecting the errorlocate Mixed Integer Program","text":"following sections example given linear, categorical conditional rules written Mixed Integer Problems. First let’s see rules validator can formally defined.","code":""},{"path":[]},{"path":"/articles/inspect_mip.html","id":"rule-r_imathbfx","dir":"Articles","previous_headings":"Formal description","what":"Rule ri(𝐱)r_i(\\mathbf{x})","title":"Inspecting the errorlocate Mixed Integer Program","text":"translatable rule ri(𝐱)r_i(\\mathbf{x}) can written disjunction atomic clauses Cij(x)C_i^j(x): function rir_i operates () values record 𝐱=(x1,…,xn)\\mathbf{x} = (x_1, \\ldots, x_n) TRUE (valid) FALSE (valid) ri(𝐱)=⋁jCij(𝐱) r_i(\\mathbf{x}) = \\bigvee_j C_i^j(\\mathbf{x}) atomic clause: Cij(𝐱)={𝐚T𝐱≤b𝐚T𝐱=bxj∈Fijwith Fij⊆Djxj∉Fijwith Fij⊆Dj C_i^j(\\mathbf{x}) = \\left\\{   \\begin{array}{l}  \\mathbf{}^T\\mathbf{x} \\leq b \\\\   \\mathbf{}^T\\mathbf{x} = b \\\\   x_j \\F_{ij}  \\textrm{} F_{ij} \\subseteq D_j \\\\   x_j \\\\F_{ij} \\textrm{} F_{ij} \\subseteq D_j \\\\   \\end{array} \\right. linear, categorical conditional rule rir_i can written form.","code":""},{"path":"/articles/inspect_mip.html","id":"example-1","dir":"Articles","previous_headings":"Formal description","what":"Example 1","title":"Inspecting the errorlocate Mixed Integer Program","text":"rule (income > 0) age >= 16 can written (income <= 0 age >=16)","code":"rules <- validator(example_1 = if (income > 0) age >= 16) rules$exprs() #> $example_1 #> income <= 0 | (age - 16 >= -1e-08) #> attr(,\"reference\") #> example_1  #>         1"},{"path":"/articles/inspect_mip.html","id":"example-2","dir":"Articles","previous_headings":"Formal description","what":"Example 2","title":"Inspecting the errorlocate Mixed Integer Program","text":"rule (has_house == \"yes\") income >= 1000) can written (has_house != \"yes\" age >=1000)","code":"rules <- validator(example_2 = if (has_house == \"yes\") income >= 1000) rules$exprs() #> $example_2 #> has_house != \"yes\" | (income - 1000 >= -1e-08) #> attr(,\"reference\") #> example_2  #>         1"},{"path":"/articles/inspect_mip.html","id":"rule-system","dir":"Articles","previous_headings":"","what":"Rule system:","title":"Inspecting the errorlocate Mixed Integer Program","text":"rules form system R(𝐱)R(\\mathbf{x}): R(𝐱)=⋀iri R(\\mathbf{x}) = \\bigwedge_i r_i  means rules rir_i must valid. R(𝐱)R(\\mathbf{x}) true record 𝐱\\mathbf{x}, record valid, otherwise one () rules violated.","code":""},{"path":"/articles/inspect_mip.html","id":"mixed-integer-programming-to-fh","dir":"Articles","previous_headings":"","what":"Mixed Integer Programming to FH","title":"Inspecting the errorlocate Mixed Integer Program","text":"rule set R(𝐱)R(\\mathbf{x}) can translated mip problem solved. Minimize f(𝐱)=0;s.t. 𝐑𝐱≤𝐝 \\begin{array}{r}   \\textrm{Minimize } f(\\mathbf{x}) = 0; \\\\   \\textrm{s.t. }\\mathbf{Rx} \\leq \\mathbf{d} \\\\ \\end{array}  - f(𝐱)f(\\mathbf{x}) (weighted) number changed variable: δi∈0,1\\delta_i \\{0,1} f(𝐱)=∑=1Nwiδi f(\\mathbf{x}) = \\sum_{=1}^N w_i \\delta_i 𝐑\\mathbf{R} contains rules: 𝐑H(𝐱)≤𝐝H\\mathbf{R}_H(\\mathbf{x}) \\leq \\mathbf{d}_H specified validate/validator 𝐑0(𝐱,𝛅)≤𝐝0\\mathbf{R}_0(\\mathbf{x}, \\mathbf{\\delta}) \\leq \\mathbf{d}_0 : soft constraints try fix current record 𝐱\\mathbf{x} observed values.","code":""},{"path":[]},{"path":"/articles/inspect_mip.html","id":"linear-rules","dir":"Articles","previous_headings":"Enter inspect_mip:","what":"Linear rules","title":"Inspecting the errorlocate Mixed Integer Program","text":"users use function locate_errors find errors. function inspect_mip works exactly , except operates just one record stead whole data.frame. result inspect_mip mip object, yet executed can inspected. detect two errors dataset: Lets inspect first record mip object contains mip problem executed. can inspect lp problem, prior solving lpSolveApi Validator rules r1 r2 encoded two lines model. values current record encoded soft constraints age_ub, age_lb, income_lb income_ub. constraints try fix values age 12 income 2000, can violated, setting .delta_age .delta_income 1. large problems lp problem can written disk inspection execute mip project, lp solver executed problem: Extra arguments passed lpSolveAPI. result object contains several properties: res$solution indicates solution found res$s indicates lpSolveAPI status, kind solution found. res$errors indicates fields/values deemed erroneous: res$values contains values valid solution found lpsolver: Note solver found setting age 12 18 gives valid solution. .delta_age = 1 indicates age contained error. result object res also contains lp object optimization. object can investigated using lpSolveAPI functions. Note lp problem simplified. example single variable constraints,lp problem/object solving shows solver optimized rules: moved rule r1 r2 Lower boundary conditions. also removed age_lb superfluous respect boundary conditions.","code":"rules <- validator( r1 = age >= 18                   , r2 = income >= 0                   ) data <- data.frame(age = c(12, 35), income = c(2000, -1000)) data #>   age income #> 1  12   2000 #> 2  35  -1000 summary(confront(data, rules)) #>   name items passes fails nNA error warning           expression #> 1   r1     2      1     1   0 FALSE   FALSE   age - 18 >= -1e-08 #> 2   r2     2      1     1   0 FALSE   FALSE income - 0 >= -1e-08 locate_errors(data, rules)$errors #>        age income #> [1,]  TRUE  FALSE #> [2,] FALSE   TRUE mip <- inspect_mip(data, rules) #> Warning: Taking record 1, ignoring rest of the records... # inspect the lp problem (prior to solving it with lpsolveAPI) lp <- mip$to_lp() print(lp) Model name: errorlocate                         age          income      .delta_age   .delta_income              Minimize                0               0  1.003699720604  1.233196748654              r1                     -1               0               0               0  <=    -18   r2                      0              -1               0               0  <=      0   age_ub                  1               0          -1e+07               0  <=     12   income_ub               0               1               0          -1e+07  <=   2000   age_lb                 -1               0          -1e+07               0  <=    -12   income_lb               0              -1               0          -1e+07  <=  -2000   Kind                  Std             Std             Std             Std              Type                 Real            Real             Int             Int              Upper                 Inf             Inf               1               1              Lower                -Inf            -Inf               0               0 mip$write_lp(\"my_problem.lp\") res <- mip$execute() names(res) #> [1] \"s\"        \"solution\" \"values\"   \"lp\"       \"adapt\"    \"errors\" res$solution #> [1] TRUE res$s #> [1] 0 res$errors #>    age income  #>   TRUE  FALSE res$values #>           age        income    .delta_age .delta_income  #>            18          2000             1             0 # lp problem after solving res$lp Model name: errorlocate                         age          income      .delta_age   .delta_income              Minimize                0               0  1.003699720604  1.233196748654              age_ub                  1               0          -1e+07               0  <=     12   income_ub               0               1               0          -1e+07  <=   2000   income_lb               0              -1               0          -1e+07  <=  -2000   Kind                  Std             Std             Std             Std              Type                 Real            Real             Int             Int              Upper                 Inf             Inf               1               1              Lower                  18               0               0               0"},{"path":"/articles/inspect_mip.html","id":"categorical-rule","dir":"Articles","previous_headings":"Enter inspect_mip:","what":"Categorical rule","title":"Inspecting the errorlocate Mixed Integer Program","text":"categorical rules, category coded separate column/mip variable: e.g. working variable, two categories (“job”, “retired”), mip problem encoded follows: Row r1 indicates either working:job working:retired must true. Kind row (SOS) indicates variables share switch, one can set.","code":"rules <- validator( r1 = working %in% c(\"job\",\"retired\")                  ) data <- data.frame(working=\"?\") mip <- inspect_mip(data, rules) mip$to_lp() Model name: errorlocate                   working:?      working:job  working:retired   .delta_working         Minimize                0                0                0   1.289767244598         r1                      0                1                1                0  =  1   working                 1                0                0                1  =  1   Kind                  SOS              SOS              SOS              Std         Type                  Int              Int              Int              Int         Upper                   1                1                1                1         Lower                   0                0                0                0 mip$execute()$values #>       working:?     working:job working:retired  .delta_working  #>               0               1               0               1"},{"path":"/articles/inspect_mip.html","id":"multiple-categories","dir":"Articles","previous_headings":"Enter inspect_mip: > Categorical rule","what":"Multiple categories:","title":"Inspecting the errorlocate Mixed Integer Program","text":"categorical variables also possible specify -rules. encoded one mip rule:","code":"rules <- validator( r1 = if (voted == TRUE) adult == TRUE) data <- data.frame(voted = TRUE, adult = FALSE) mip <- inspect_mip(data, rules) mip$to_lp() Model name: errorlocate                      adult           voted    .delta_adult    .delta_voted          Minimize               0               0  1.087470313418  1.437300330378          r1                    -1               1               0               0  <=  0   voted                  0               1               0               1   =  1   adult                 -1               0               1               0   =  0   Kind                 Std             Std             Std             Std          Type                 Int             Int             Int             Int          Upper                  1               1               1               1          Lower                  0               0               0               0 mip$execute()$values #>        adult        voted .delta_adult .delta_voted  #>            1            1            1            0"},{"path":"/articles/inspect_mip.html","id":"conditional-rule","dir":"Articles","previous_headings":"Enter inspect_mip:","what":"Conditional rule","title":"Inspecting the errorlocate Mixed Integer Program","text":"errorlocate encodes rule multiple rules (noted theoretical section ), rule r1 chopped 1 rule + 2 sub rules: r1: (income > 0) age >= 16: r1._lin1: (r1._lin1 == FALSE) income <= 0 r1._lin2: (r1._lin2 == FALSE) age >= 16 r1: r1._lin1 == FALSE | r1._lin2 == FALSE can seen : resulting lp model :","code":"rules <- validator( r1 = if (income > 0) age >= 16) data <- data.frame(age = 12, income = 2000) mip <- inspect_mip(data, rules) mip$mip_rules() #> [[1]] #> r1: r1._lin1 + r1._lin2 <= 1 #> [[2]] #> r1._lin1: income - 1e+07*r1._lin1 <= 0 #> [[3]] #> r1._lin2: -age - 1e+07*r1._lin2 <= -16 #> [[4]] #> income_ub: income - 1e+07*.delta_income <= 2000 #> [[5]] #> age_ub: age - 1e+07*.delta_age <= 12 #> [[6]] #> income_lb: -income - 1e+07*.delta_income <= -2000 #> [[7]] #> age_lb: -age - 1e+07*.delta_age <= -12 mip$to_lp() Model name: errorlocate                         age          income      .delta_age   .delta_income        r1._lin1        r1._lin2              Minimize                0               0  1.160192865412  1.017120666336               0               0              r1                      0               0               0               0               1               1  <=      1   r1._lin1                0               1               0               0          -1e+07               0  <=      0   r1._lin2               -1               0               0               0               0          -1e+07  <=    -16   income_ub               0               1               0          -1e+07               0               0  <=   2000   age_ub                  1               0          -1e+07               0               0               0  <=     12   income_lb               0              -1               0          -1e+07               0               0  <=  -2000   age_lb                 -1               0          -1e+07               0               0               0  <=    -12   Kind                  Std             Std             Std             Std             Std             Std              Type                 Real            Real             Int             Int             Int             Int              Upper                 Inf             Inf               1               1               1               1              Lower                -Inf            -Inf               0               0               0               0 mip$execute()$values #>           age        income    .delta_age .delta_income      r1._lin1  #>            12             0             0             1             0  #>      r1._lin2  #>             1"},{"path":"/articles/inspect_mip.html","id":"alltogether","dir":"Articles","previous_headings":"Enter inspect_mip:","what":"Alltogether:","title":"Inspecting the errorlocate Mixed Integer Program","text":"works together categorical, linear conditional rules.","code":"rules <- validator( r1 = working %in% c(\"no_job\", \"job\",\"retired\")                   , r2 = if (age < 12) working == \"no_job\"                   , r3 = if (working == \"retired\") age > 50                   , r4 = age >=0                   )  data <- data.frame(age = 12, working=\"retired\") mip <- inspect_mip(data, rules) mip$execute()$errors #> working     age  #>   FALSE    TRUE"},{"path":"/articles/inspect_mip.html","id":"weights","dir":"Articles","previous_headings":"Enter inspect_mip:","what":"Weights","title":"Inspecting the errorlocate Mixed Integer Program","text":"weights variable normally set 1, errorlocate adds random remainder weights: solutions unique reproducible (using set.seed). $objective contains generated weights: assigned delta variables objective function mip.","code":"set.seed(42) rules <- validator( r1 = if (voted == TRUE) adult == TRUE) data <- data.frame(voted = TRUE, adult = FALSE) mip <- inspect_mip(data, rules, weight = c(voted = 3, adult=1)) mip$objective #> .delta_voted .delta_adult  #>     3.457403     1.468538 mip$to_lp() Model name: errorlocate                      adult           voted    .delta_adult    .delta_voted          Minimize               0               0  1.468537706648  3.457403021748          r1                    -1               1               0               0  <=  0   voted                  0               1               0               1   =  1   adult                 -1               0               1               0   =  0   Kind                 Std             Std             Std             Std          Type                 Int             Int             Int             Int          Upper                  1               1               1               1          Lower                  0               0               0               0"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Edwin de Jonge. Author, maintainer. Mark van der Loo. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"de Jonge E, van der Loo M (2025). errorlocate: Locate Errors Validation Rules. R package version 1.1.2, https://github.com/data-cleaning/errorlocate.","code":"@Manual{,   title = {errorlocate: Locate Errors with Validation Rules},   author = {Edwin {de Jonge} and Mark {van der Loo}},   year = {2025},   note = {R package version 1.1.2},   url = {https://github.com/data-cleaning/errorlocate}, }"},{"path":"/index.html","id":"error-localization","dir":"","previous_headings":"","what":"Locate Errors with Validation Rules","title":"Locate Errors with Validation Rules","text":"Find errors data given set validation rules. errorlocate helps identify obvious errors raw datasets. works tandem package validate. validate formulate data validation rules data must comply. example: “age negative”: age >= 0. “person married, must older 16 years”: (married ==TRUE) age > 16. “Profit turnover minus cost”: profit == turnover - cost. validate can check record valid , identify variables responsible invalidation. may seem simple task, actually quite tricky: set validation rules forms web dependent variables: changing value invalid record repair rule 1, may invalidate record rule 2. errorlocate provides small framework record based error detection implements Felligi Holt algorithm. algorithm assumes information available values record set validation rules. algorithm minimizes (weighted) number values need adjusted remove invalidation.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Locate Errors with Validation Rules","text":"errorlocate can installed CRAN: Beta versions can installed drat: latest development version errorlocate can installed github devtools:","code":"install.packages(\"errorlocate\") drat::addRepo(\"data-cleaning\") install.packages(\"errorlocate\") devtools::install_github(\"data-cleaning/errorlocate\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Locate Errors with Validation Rules","text":"","code":"library(errorlocate) #> Loading required package: validate rules <- validator( profit == turnover - cost                   , cost >= 0.6 * turnover                   , turnover >= 0                   , cost >= 0 # is implied )  data <- data.frame(profit=750, cost=125, turnover=200)  data_no_error <- replace_errors(data, rules)  # faulty data was replaced with NA print(data_no_error) #>   profit cost turnover #> 1     NA  125      200  er <- errors_removed(data_no_error)  print(er) #> call:  locate_errors(data, x, ref, ..., cl = cl)  #> located  1  error(s). #> located  0  missing value(s). #> Use 'summary', 'values', '$errors' or '$weight', to explore and retrieve the errors.  summary(er) #> Variable: #>       name errors missing #> 1   profit      1       0 #> 2     cost      0       0 #> 3 turnover      0       0 #> Errors per record: #>   errors records #> 1      1       1  er$errors #>      profit  cost turnover #> [1,]   TRUE FALSE    FALSE"},{"path":"/reference/ErrorLocalizer-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Base class for class locate errors based on rules and data — ErrorLocalizer-class","title":"Base class for class locate errors based on rules and data — ErrorLocalizer-class","text":"ErrorLocalizer can used base class implement new error localization algorithm. derived class must implement two methods: initialize, called error localization done locate operates upon data. extra parameter ... can used supply algorithmic specific parameters.","code":""},{"path":"/reference/FHLocalizer-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Feligi-Holt Errorlocalizer — FHLocalizer-class","title":"Feligi-Holt Errorlocalizer — FHLocalizer-class","text":"Implementation Feligi-Holt algorithm using ErrorLocalizer base class. Given set validation rules dataset Feligi-Holt algorithm finds record smallest (weighted) combination variables erroneous ().","code":""},{"path":"/reference/FHLocalizer-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Feligi-Holt Errorlocalizer — FHLocalizer-class","text":"users need class can use locate_errors(). errorlocalizer implements feligi holt using MIP-solver. problems coefficients validation rules data different, consider scaling data.","code":""},{"path":"/reference/MipRules-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a mip object from a validator object — MipRules-class","title":"Create a mip object from a validator object — MipRules-class","text":"Create mip object validate::validator() object. utility class translates validor object mixed integer problem can solved. users use locate_errors() handle translation execution automatically. class provided users can implement derive alternative solution.","code":""},{"path":"/reference/MipRules-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Create a mip object from a validator object — MipRules-class","text":"MipRules class contains following methods: $execute() calls mip solver execute rules. $to_lp(): transforms object lp_solve object $is_infeasible Checks current system mixed integer rules feasible. $set_values: set values weights variables (determines objective function).","code":""},{"path":[]},{"path":"/reference/MipRules-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a mip object from a validator object — MipRules-class","text":"","code":"rules <- validator(x > 1) mr <- miprules(rules) mr$to_lp() #> Model name: errorlocate #>              x             #> Minimize     0             #> V1          -1  <=  -1.001 #> Kind       Std             #> Type      Real             #> Upper      Inf             #> Lower     -Inf             mr$set_values(c(x=0), weights=c(x=1)) mr$execute() #> $s #> [1] 0 #>  #> $solution #> [1] TRUE #>  #> $values #>        x .delta_x  #>    1.001    1.000  #>  #> $lp #> Model name: errorlocate #>                        x        .delta_x        #> Minimize               0  1.600760886212        #> x_ub                   1          -1e+07  <=  0 #> Kind                 Std             Std        #> Type                Real             Int        #> Upper                Inf               1        #> Lower              1.001               0        #>  #> $adapt #>    x  #> TRUE  #>  #> $errors #>    x  #> TRUE  #>"},{"path":"/reference/add_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"Add (a small amount of) noise — add_noise","title":"Add (a small amount of) noise — add_noise","text":"Utility function add small positive noise weights. mainly done randomly choose solutions equal weight. Without adding noise weights lp solvers may return identical solution multiple solutions equal weight. generated noise positive prevent weights zero negative.","code":""},{"path":"/reference/add_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add (a small amount of) noise — add_noise","text":"","code":"add_noise(x, max_delta = NULL, ...)"},{"path":"/reference/add_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add (a small amount of) noise — add_noise","text":"x numeric vector matrix. x matrix, function applied row matrix. max_delta supplied noise drawn [0,max_delta] otherwise see details ... currently used","code":""},{"path":"/reference/add_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add (a small amount of) noise — add_noise","text":"numeric vector/matrix noise applied.","code":""},{"path":"/reference/add_noise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add (a small amount of) noise — add_noise","text":"max_delta supplied, add_noise use minimum difference larger zero divided length(x).","code":""},{"path":"/reference/cat_as_mip_rules.html","id":null,"dir":"Reference","previous_headings":"","what":"get categorical rules as mip_rules — cat_as_mip_rules","title":"get categorical rules as mip_rules — cat_as_mip_rules","text":"get categorical rules mip_rules","code":""},{"path":"/reference/cat_as_mip_rules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get categorical rules as mip_rules — cat_as_mip_rules","text":"","code":"cat_as_mip_rules(x, ...)"},{"path":"/reference/cat_as_mip_rules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get categorical rules as mip_rules — cat_as_mip_rules","text":"x expressionset object ... used","code":""},{"path":"/reference/cat_as_mip_rules.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get categorical rules as mip_rules — cat_as_mip_rules","text":"list mip_rule","code":""},{"path":"/reference/cat_coefficients.html","id":null,"dir":"Reference","previous_headings":"","what":"Get coefficient matrix from categorical rules — cat_coefficients","title":"Get coefficient matrix from categorical rules — cat_coefficients","text":"Get coefficient matrix categorical edits, similar linear_coefficients.","code":""},{"path":"/reference/cat_coefficients.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get coefficient matrix from categorical rules — cat_coefficients","text":"","code":"cat_coefficients(x, ...)"},{"path":"/reference/cat_coefficients.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get coefficient matrix from categorical rules — cat_coefficients","text":"x validator object ... used","code":""},{"path":"/reference/errorlocate-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Find errors in data given a set of validation rules. — errorlocate-package","title":"Find errors in data given a set of validation rules. — errorlocate-package","text":"Find errors data given set validation rules. errorlocate helps identify obvious errors raw datasets.","code":""},{"path":"/reference/errorlocate-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find errors in data given a set of validation rules. — errorlocate-package","text":"works tandem package validate. validate formulate data validation rules data must comply. example: \"age negative\": age >= 0 validate can identify record valid , identify variables responsible invalidation. may seem simple task, actually quite tricky:  set validation rules form web dependent variables: changing value invalid record repair rule 1, may invalidate record rule 2. Errorlocate provides small framework record based error detection implements Felligi Holt algorithm. algorithm assumes information available values record set validation rules. algorithm minimizes (weighted) number values need adjusted remove invalidation. errorlocate package translates validation error localization problem mixed integer problem uses mip solver find solution.","code":""},{"path":"/reference/errorlocate-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find errors in data given a set of validation rules. — errorlocate-package","text":"T. De Waal (2003) Processing Erroneous Unsafe Data. PhD thesis, University Rotterdam. Van der Loo, M., de Jonge, E, Data Cleaning Applications R E. De Jonge Van der Loo, M. (2012) Error localization mixed-integer program editrules. lp_solve Kjell Konis. (2011). lpSolveAPI: R Interface lp_solve version 5.5.2.0. R package version 5.5.2.0-5. http://CRAN.R-project.org/package=lpSolveAPI","code":""},{"path":[]},{"path":"/reference/errorlocate-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find errors in data given a set of validation rules. — errorlocate-package","text":"Maintainer: Edwin de Jonge edwindjonge@gmail.com (ORCID) Authors: Mark van der Loo mark.vanderloo@gmail.com","code":""},{"path":"/reference/errorlocation.html","id":null,"dir":"Reference","previous_headings":"","what":"Error location object — errorlocation-class","title":"Error location object — errorlocation-class","text":"Errorlocation contains result error detection. Errors can record based variable based. record based error restricted within one observation. errorlocate() using Felligi Holt algorithm assumes errors record based. variable based error flaw  uni- multivariate distribution. correct error multiple observations aggregated number adjusted.","code":""},{"path":"/reference/errorlocation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Error location object — errorlocation-class","text":"Current implementation assumes errors record based. error locations can retrieved using method validate::values() matrix rows columns, dimensions data.frame checked. errors purely column based, dataset based, errorlocations return matrix rows cells set TRUE. validate::values() return NA missing values.","code":""},{"path":"/reference/errorlocation.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"Error location object — errorlocation-class","text":"$errors: matrix indicating values erronuous (TRUE), missing (NA) valid (FALSE) $weight: total weight per record. weight 0 means errors detected. $status: status mip solver record. $duration: number seconds processing record.","code":""},{"path":[]},{"path":"/reference/errors_removed.html","id":null,"dir":"Reference","previous_headings":"","what":"Get location of removed errors from a 'cleaned' data set — errors_removed","title":"Get location of removed errors from a 'cleaned' data set — errors_removed","text":"errors_removed retrieves errors detected replace_errors()","code":""},{"path":"/reference/errors_removed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get location of removed errors from a 'cleaned' data set — errors_removed","text":"","code":"errors_removed(x, ...)"},{"path":"/reference/errors_removed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get location of removed errors from a 'cleaned' data set — errors_removed","text":"x data.frame checked errors ... used","code":""},{"path":"/reference/errors_removed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get location of removed errors from a 'cleaned' data set — errors_removed","text":"errorlocation-class() object","code":""},{"path":[]},{"path":"/reference/errors_removed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get location of removed errors from a 'cleaned' data set — errors_removed","text":"","code":"rules <- validator( profit + cost == turnover               , cost - 0.6*turnover >= 0               , cost>= 0               , turnover >= 0 ) data <- data.frame(profit=755, cost=125, turnover=200)  data_no_error <- replace_errors(data,rules)  # faulty data was replaced with NA data_no_error #>   profit cost turnover #> 1     NA  125      200  errors_removed(data_no_error) #> call:  locate_errors(data, x, ref, ..., cl = cl, Ncpus = Ncpus)  #> located  1  error(s). #> located  0  missing value(s). #> Use 'summary', 'values', '$errors' or '$weight', to explore and retrieve the errors.  # a bit more control, you can supply the result of locate_errors # to replace_errors, which is a good thing, otherwise replace_errors will call # locate_errors internally. error_locations <- locate_errors(data, rules) replace_errors(data, error_locations) #>   profit cost turnover #> 1     NA  125      200"},{"path":"/reference/expand_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a weight matrix — expand_weights","title":"Create a weight matrix — expand_weights","text":"Expands weight specification weight matrix used locate_errors replace_errors. Weights allow \"guiding\" errorlocalization process, less reliable values/variables less weight selected first. See details specification.","code":""},{"path":"/reference/expand_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a weight matrix — expand_weights","text":"","code":"expand_weights(dat, weight = NULL, as.data.frame = FALSE, ...)"},{"path":"/reference/expand_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a weight matrix — expand_weights","text":"dat data.frame data checked weight weight specification, see details. .data.frame TRUE data.frame returned. ... unused","code":""},{"path":"/reference/expand_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a weight matrix — expand_weights","text":"matrix data.frame dimensions dat","code":""},{"path":"/reference/expand_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a weight matrix — expand_weights","text":"weight fine tuning needed, possible scenario generate weight data.frame using expand_weights adjust executing locate_errors() replace_errors(). following specifications weight supported: NULL: generates weight matrix 1's named numeric, unmentioned columns weight 1 unnamed numeric length equal ncol(dat) data.frame number rows dat matrix number rows dat Inf, NA weights interpreted variables must changed fixated. Inf weights perform much better setting weight large number.","code":""},{"path":[]},{"path":"/reference/expand_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a weight matrix — expand_weights","text":"","code":"dat <- read.csv(text= \"age,country   49,     NL   23,     DE \", strip.white=TRUE)  weight <- c(age = 2, country = 1) expand_weights(dat, weight) #>      age country #> [1,]   2       1 #> [2,]   2       1  weight <- c(2, 1) expand_weights(dat, weight, as.data.frame = TRUE) #>   age country #> 1   2       1 #> 2   2       1  # works too weight <- c(country=5) expand_weights(dat, weight) #>      age country #> [1,]   1       5 #> [2,]   1       5  # specify a per row weight for country weight <- data.frame(country=c(1,5)) expand_weights(dat, weight) #>      age country #> [1,]   1       1 #> [2,]   1       5  # country should not be changed! weight <- c(country = Inf) expand_weights(dat, weight) #>      age country #> [1,]   1     Inf #> [2,]   1     Inf"},{"path":"/reference/expect_values.html","id":null,"dir":"Reference","previous_headings":"","what":"expect values — expect_values","title":"expect values — expect_values","text":"expect values","code":""},{"path":"/reference/expect_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"expect values — expect_values","text":"","code":"expect_values(values, weights, delta_names = NULL, ...)"},{"path":"/reference/expect_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"expect values — expect_values","text":"values named list values. weights named numeric equal length values. delta_names alternative names binary variables. (used log) ... used","code":""},{"path":"/reference/inspect_mip.html","id":null,"dir":"Reference","previous_headings":"","what":"inspect the mip problem formulation — inspect_mip","title":"inspect the mip problem formulation — inspect_mip","text":"Utility function inspect mip problem record. inspect_mip can used \"drop-\" replacement locate_errors(), works first record.","code":""},{"path":"/reference/inspect_mip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"inspect the mip problem formulation — inspect_mip","text":"","code":"inspect_mip(data, x, weight, ...)"},{"path":"/reference/inspect_mip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"inspect the mip problem formulation — inspect_mip","text":"data data checked x validation rules errorlocalizer object used finding possible errors. weight numeric optional weight specification used error localization (see expand_weights()). ... optional parameters passed lpSolveAPI::lp.control() (see details)","code":""},{"path":"/reference/inspect_mip.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"inspect the mip problem formulation — inspect_mip","text":"may sometimes handy find happening exactly record. See example section finding inspect_mip. See vignette(\"inspect_mip\") details.","code":""},{"path":[]},{"path":"/reference/inspect_mip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"inspect the mip problem formulation — inspect_mip","text":"","code":"rules <- validator(x > 1) data <- list(x = 0) weight <- c(x = 1)  mip <- inspect_mip(data, rules) print(mip) #> Mip rules object: #>    methods: '$to_lp()', '$execute', '$set_values()' #>    properties: '$mip_rules', '$objective', '$is_infeasible', '$rules' #>  #> Generates the lp program (see ?inspect_mip)  #>  #> Model name: errorlocate #>                        x        .delta_x             #> Minimize               0  1.195669834734             #> V1                    -1               0  <=  -1.001 #> x_ub                   1          -1e+07  <=       0 #> x_lb                  -1          -1e+07  <=       0 #> Kind                 Std             Std             #> Type                Real             Int             #> Upper                Inf               1             #> Lower               -Inf               0              # inspect the lp problem (prior to solving it with lpsolveAPI) lp <- mip$to_lp() print(lp) #> Model name: errorlocate #>                        x        .delta_x             #> Minimize               0  1.195669834734             #> V1                    -1               0  <=  -1.001 #> x_ub                   1          -1e+07  <=       0 #> x_lb                  -1          -1e+07  <=       0 #> Kind                 Std             Std             #> Type                Real             Int             #> Upper                Inf               1             #> Lower               -Inf               0              # for large problems write the lp problem to disk for inspection # lpSolveAPI::write.lp(lp, \"my_problem.lp\")  # solve the mip system / find a solution res <- mip$execute() names(res) #> [1] \"s\"        \"solution\" \"values\"   \"lp\"       \"adapt\"    \"errors\"    # lpSolveAPI status of finding a solution res$s #> [1] 0  # lp problem after solving (often simplified version of first lp) res$lp #> Model name: errorlocate #>                        x        .delta_x        #> Minimize               0  1.195669834734        #> x_ub                   1          -1e+07  <=  0 #> Kind                 Std             Std        #> Type                Real             Int        #> Upper                Inf               1        #> Lower              1.001               0         # records that are deemed \"faulty\" res$errors #>    x  #> TRUE   # values of variables used in the mip formulation. Also contains a valid solution # for \"faulty\" variables res$values #>        x .delta_x  #>    1.001    1.000   # see the derived mip rules and objective function, used in the construction of # lp problem mip$mip_rules() #> [[1]] #> V1: -x < -1 #> [[2]] #> x_ub: x - 1e+07*.delta_x <= 0 #> [[3]] #> x_lb: -x - 1e+07*.delta_x <= 0 mip$objective #> .delta_x  #>  1.19567"},{"path":"/reference/is_categorical.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if rules are categorical — is_categorical","title":"Check if rules are categorical — is_categorical","text":"Check rules categorical","code":""},{"path":"/reference/is_categorical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if rules are categorical — is_categorical","text":"","code":"is_categorical(x, ...)"},{"path":"/reference/is_categorical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if rules are categorical — is_categorical","text":"x validator expression object ... used","code":""},{"path":"/reference/is_categorical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if rules are categorical — is_categorical","text":"logical indicating rules purely categorical/logical","code":""},{"path":"/reference/is_categorical.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check if rules are categorical — is_categorical","text":"#' @note errorlocate supports linear, categorical conditional rules used finding errors. rule types ignored error finding.","code":""},{"path":[]},{"path":"/reference/is_categorical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if rules are categorical — is_categorical","text":"","code":"v <- validator( A %in% c(\"a1\", \"a2\")               , B %in% c(\"b1\", \"b2\")               , if (A == \"a1\") B == \"b1\"               , y > x               )  is_categorical(v) #> [1]  TRUE  TRUE  TRUE FALSE"},{"path":"/reference/is_conditional.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if rules are conditional rules — is_conditional","title":"Check if rules are conditional rules — is_conditional","text":"Check rules conditional rules","code":""},{"path":"/reference/is_conditional.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if rules are conditional rules — is_conditional","text":"","code":"is_conditional(rules, ...)"},{"path":"/reference/is_conditional.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if rules are conditional rules — is_conditional","text":"rules validator object containing validation rules ... used","code":""},{"path":"/reference/is_conditional.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if rules are conditional rules — is_conditional","text":"logical indicating rules conditional","code":""},{"path":"/reference/is_conditional.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check if rules are conditional rules — is_conditional","text":"errorlocate supports linear, categorical conditional rules used finding errors. rule types ignored error finding.","code":""},{"path":[]},{"path":"/reference/is_conditional.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if rules are conditional rules — is_conditional","text":"","code":"v <- validator( A %in% c(\"a1\", \"a2\")               , B %in% c(\"b1\", \"b2\")               , if (A == \"a1\")  x > 1 # conditional               , if (y > 0) x >= 0 # conditional               , if (A == \"a1\") B == \"b1\" # categorical               )  is_conditional(v) #> [1] FALSE FALSE  TRUE  TRUE FALSE"},{"path":"/reference/is_linear.html","id":null,"dir":"Reference","previous_headings":"","what":"Check which rules are linear rules. — is_linear","title":"Check which rules are linear rules. — is_linear","text":"Check rules linear rules.","code":""},{"path":"/reference/is_linear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check which rules are linear rules. — is_linear","text":"","code":"is_linear(x, ...)"},{"path":"/reference/is_linear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check which rules are linear rules. — is_linear","text":"x validate::validator() object containing data validation rules ... used","code":""},{"path":"/reference/is_linear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check which rules are linear rules. — is_linear","text":"logical indicating rules (purely) linear.","code":""},{"path":"/reference/is_linear.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check which rules are linear rules. — is_linear","text":"errorlocate supports linear, categorical conditional rules used finding errors. rule types ignored error finding.","code":""},{"path":[]},{"path":"/reference/locate_errors.html","id":null,"dir":"Reference","previous_headings":"","what":"Find errors in data — locate_errors","title":"Find errors in data — locate_errors","text":"Find fields data.frame \"faulty\" using validation rules method returns found errors, according specified method x. Use method replace_errors(), automatically remove errors. Use [base::set.seed()] beforehand make function call reproducible. `","code":""},{"path":"/reference/locate_errors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find errors in data — locate_errors","text":"","code":"locate_errors(   data,   x,   ...,   cl = NULL,   Ncpus = getOption(\"Ncpus\", 1),   timeout = 60 )  # S4 method for class 'data.frame,validator' locate_errors(   data,   x,   weight = NULL,   ref = NULL,   ...,   cl = NULL,   Ncpus = getOption(\"Ncpus\", 1),   timeout = 60 )  # S4 method for class 'data.frame,ErrorLocalizer' locate_errors(   data,   x,   weight = NULL,   ref = NULL,   ...,   cl = NULL,   Ncpus = getOption(\"Ncpus\", 1),   timeout = 60 )"},{"path":"/reference/locate_errors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find errors in data — locate_errors","text":"data data checked x validation rules errorlocalizer object used finding possible errors. ... optional parameters passed lpSolveAPI::lp.control() (see details) cl optional parallel / cluster. Ncpus number nodes use. See details timeout maximum number seconds localizer use per record. weight numeric optional weight specification used error localization (see expand_weights()). ref data.frame optional reference data used rules checking","code":""},{"path":"/reference/locate_errors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find errors in data — locate_errors","text":"errorlocation-class() object describing errors found.","code":""},{"path":"/reference/locate_errors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find errors in data — locate_errors","text":"Use Inf weight specification fixate variables can changed. See expand_weights() details. locate_errors uses lpSolveAPI formulate solves mixed integer problem. details see vignettes. solver many options:  lpSolveAPI::lp.control.options. Noteworthy options used : timeout: restricts time solver spends record (seconds) break..value: set minimum weight + 1 improve speed. presolve: default errorlocate \"rows\". Set \"none\" solutions variables deemed wrong. locate_errors can run multiple cores using R package parallel. easiest way use parallel option set Ncpus number desired cores, @seealso parallel::detectCores(). Alternatively one can create cluster object (parallel::makeCluster()) use cl pass cluster object. set cl integer results parallel::mclapply(), works non-windows.","code":""},{"path":[]},{"path":"/reference/locate_errors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find errors in data — locate_errors","text":"","code":"rules <- validator( profit + cost == turnover                   , cost >= 0.6 * turnover # cost should be at least 60% of turnover                   , turnover >= 0 # can not be negative.                   ) data <- data.frame( profit   = 755                   , cost     = 125                   , turnover = 200                   )  # use set.seed to maake results reproducible set.seed(42) le <- locate_errors(data, rules)  print(le) #> call:  locate_errors(data = data, fh, ref = ref, weight = weight, ...,      cl = cl, Ncpus = Ncpus, timeout = timeout)  #> located  1  error(s). #> located  0  missing value(s). #> Use 'summary', 'values', '$errors' or '$weight', to explore and retrieve the errors. summary(le) #> Variable: #>       name errors missing #> 1   profit      1       0 #> 2     cost      0       0 #> 3 turnover      0       0 #> Errors per record: #>   errors records #> 1      1       1  v_categorical <- validator( branch %in% c(\"government\", \"industry\")                           , tax %in% c(\"none\", \"VAT\")                           , if (tax == \"VAT\") branch == \"industry\" )  data <- read.csv(text= \"   branch, tax government, VAT industry  , VAT \", strip.white = TRUE) locate_errors(data, v_categorical)$errors #>      branch   tax #> [1,]  FALSE  TRUE #> [2,]  FALSE FALSE  v_logical <- validator( citizen %in% c(TRUE, FALSE)                       , voted %in% c(TRUE, FALSE)                       ,  if (voted == TRUE) citizen == TRUE                       )  data <- data.frame(voted = TRUE, citizen = FALSE)  set.seed(42) locate_errors(data, v_logical, weight=c(2,1))$errors #>      voted citizen #> [1,] FALSE    TRUE  # try a condinational rule v <- validator( married %in% c(TRUE, FALSE)               , if (married==TRUE) age >= 17               ) data <- data.frame( married = TRUE, age = 16)  set.seed(42) locate_errors(data, v, weight=c(married=1, age=2))$errors #>      married   age #> [1,]    TRUE FALSE   # different weights per row data <- read.csv(text= \"married, age     TRUE,  16     TRUE,  14 \", strip.white = TRUE)  weight <- read.csv(text= \"married, age        1,   2        2,   1 \", strip.white = TRUE)  set.seed(42) locate_errors(data, v, weight = weight)$errors #>      married   age #> [1,]    TRUE FALSE #> [2,]   FALSE  TRUE  # fixate / exclude a variable from error localiziation # using an Inf weight weight <- c(age = Inf)  set.seed(42) locate_errors(data, v, weight = weight)$errors #>      married   age #> [1,]    TRUE FALSE #> [2,]    TRUE FALSE"},{"path":"/reference/mip_rule.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a rule used by mip — mip_rule","title":"Create a rule used by mip — mip_rule","text":"Create rule used mip","code":""},{"path":"/reference/mip_rule.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a rule used by mip — mip_rule","text":"","code":"mip_rule(a, op, b, rule, type, weight = Inf, ...)"},{"path":"/reference/mip_rule.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a rule used by mip — mip_rule","text":"named vector coefficients op operator (\"<=\", \"==\", \">=\", \">\", \"<\")","code":""},{"path":"/reference/replace_errors.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace erroneous fields with NA or a suggested value — replace_errors","title":"Replace erroneous fields with NA or a suggested value — replace_errors","text":"Find erroneous fields using locate_errors() replace fields automatically NA suggestion provided error detection algorithm.","code":""},{"path":"/reference/replace_errors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace erroneous fields with NA or a suggested value — replace_errors","text":"","code":"replace_errors(   data,   x,   ref = NULL,   ...,   cl = NULL,   Ncpus = getOption(\"Ncpus\", 1),   value = c(\"NA\", \"suggestion\") )  # S4 method for class 'data.frame,validator' replace_errors(   data,   x,   ref = NULL,   ...,   cl = NULL,   Ncpus = getOption(\"Ncpus\", 1),   value = c(\"NA\", \"suggestion\") )  # S4 method for class 'data.frame,ErrorLocalizer' replace_errors(   data,   x,   ref = NULL,   ...,   cl = NULL,   Ncpus = getOption(\"Ncpus\", 1),   value = c(\"NA\", \"suggestion\") )  # S4 method for class 'data.frame,errorlocation' replace_errors(   data,   x,   ref = NULL,   ...,   cl = NULL,   Ncpus = 1,   value = c(\"NA\", \"suggestion\") )"},{"path":"/reference/replace_errors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace erroneous fields with NA or a suggested value — replace_errors","text":"data data checked x validate::validator() errorlocation object. errorlocation already available (locate_errors()) efficient. ref optional reference data set ... parameters handed locate_errors() cl optional cluster parallel execution (see details) Ncpus number nodes use. (see details) value NA","code":""},{"path":"/reference/replace_errors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace erroneous fields with NA or a suggested value — replace_errors","text":"data erroneous values removed.","code":""},{"path":"/reference/replace_errors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Replace erroneous fields with NA or a suggested value — replace_errors","text":"Note can also use result locate_errors() replace_errors. procedure takes long time locate_errors called previously preferred way, otherwise locate_errors executed . errors removed data.frame can retrieved function errors_removed(). control error localization see locate_errors(). replace_errors parallelization options locate_errors() (see ).","code":""},{"path":"/reference/replace_errors.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Replace erroneous fields with NA or a suggested value — replace_errors","text":"general better replace erroneous fields NA apply proper imputation method. Suggested values error localization method may introduce undesired bias.","code":""},{"path":[]},{"path":"/reference/replace_errors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace erroneous fields with NA or a suggested value — replace_errors","text":"","code":"rules <- validator( profit + cost == turnover               , cost - 0.6*turnover >= 0               , cost>= 0               , turnover >= 0 ) data <- data.frame(profit=755, cost=125, turnover=200)  data_no_error <- replace_errors(data,rules)  # faulty data was replaced with NA data_no_error #>   profit cost turnover #> 1     NA  125      200  errors_removed(data_no_error) #> call:  locate_errors(data, x, ref, ..., cl = cl, Ncpus = Ncpus)  #> located  1  error(s). #> located  0  missing value(s). #> Use 'summary', 'values', '$errors' or '$weight', to explore and retrieve the errors.  # a bit more control, you can supply the result of locate_errors # to replace_errors, which is a good thing, otherwise replace_errors will call # locate_errors internally. error_locations <- locate_errors(data, rules) replace_errors(data, error_locations) #>   profit cost turnover #> 1     NA  125      200"},{"path":"/reference/translate_mip_lp.html","id":null,"dir":"Reference","previous_headings":"","what":"translate linear rules into an lp problem — translate_mip_lp","title":"translate linear rules into an lp problem — translate_mip_lp","text":"translate linear rules lp problem","code":""},{"path":"/reference/translate_mip_lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"translate linear rules into an lp problem — translate_mip_lp","text":"","code":"translate_mip_lp(rules, objective = NULL, eps = 0.001, ...)"},{"path":"/reference/translate_mip_lp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"translate linear rules into an lp problem — translate_mip_lp","text":"rules mip rules objective function eps accuracy equality/inequality ... additional lpSolveAPI::lp.control() parameters set mip problem","code":""},{"path":"/news/index.html","id":"errorlocate-111","dir":"Changelog","previous_headings":"","what":"errorlocate 1.1.1","title":"errorlocate 1.1.1","text":"CRAN release: 2023-09-30 Fix R 4.3.2: .atomic(NULL) TRUE, now FALSE.","code":""},{"path":"/news/index.html","id":"errorlocate-11","dir":"Changelog","previous_headings":"","what":"errorlocate 1.1","title":"errorlocate 1.1","text":"CRAN release: 2022-06-29 values > 1e7 combination another value NA locate_errors generated error. Reported fixed Ramon Reinders (issue #36) support in_range (issue #33)","code":""},{"path":"/news/index.html","id":"errorlocate-100","dir":"Changelog","previous_headings":"","what":"errorlocate 1.0.0","title":"errorlocate 1.0.0","text":"CRAN release: 2022-03-31 Fixed nasty bug variable names mangled lpsolveAPI, depending seed / added random noise. Thanks Patrick Driessens Added expand_weights, helps specifying detailed weights records Removed bug: Ncpus ignored replace_errors","code":""},{"path":"/news/index.html","id":"errorlocate-099","dir":"Changelog","previous_headings":"","what":"errorlocate 0.9.9","title":"errorlocate 0.9.9","text":"CRAN release: 2021-05-03 Added support Inf weights, thanks Guido van den Heuvel. Improved default setting solver epsd = 1e-12 provides better numerical stability. aggressive presolve default lpSolveAPI (c(“rows”, “cols”)) (issue #34) , switching back presolve=“rows”. Thanks Sander Scholtus.","code":""},{"path":"/news/index.html","id":"errorlocate-098","dir":"Changelog","previous_headings":"","what":"errorlocate 0.9.8","title":"errorlocate 0.9.8","text":"CRAN release: 2021-02-01 Added parallel processing options, resulting speed memory consumption improvements. (also Ncpus=1). simple ratio’s taken account rewritten linear rules: cost/turnover > 0.6 rewritten cost > 0.6 * turnover. bug fix issue #31: record invalid, rules involving invalidation contained missing variables, record skipped errorlocate. Bug fix issue #30: value >= 1e7 encountered, fields flagged erroneous. Thanks Garðar Páll Gíslason. Bug fix log1p, log10 function approximation. long running locate_error sessions, mip solver returned records numerical instability error code. Seems instability lpSolve. Resubmitting record return solution. numerical instability lpSolve reported record try . fails, saved mps format temporary directory (warning).","code":""},{"path":"/news/index.html","id":"errorlocate-051","dir":"Changelog","previous_headings":"","what":"errorlocate 0.5.1","title":"errorlocate 0.5.1","text":"CRAN release: 2020-11-27 Better name generation soft linear equality constraints values data.frame used constraints added matrix. Fix issue #25, variable contains one category. Thanks @nickforr. Fix/warning issue #27, using integer variable categories. Thanks Jeffrey Hoogland reporting. Fix handling NA logical values (issue #29). Added status duration info errorlocation. Thanks Sander Scholtus Improved progress bar, showing percentage taking account records without errors added inspect_mip function, allowing depth examination mip translation execution. Making easier debug/find wrong record / rule set experimental functionality log transformed variables, can switched options(errorlocate.allow_log = TRUE). makes possible formulate constraints total_salary >= min_salary * n_employees log(total_salary) >= log(min_salary) + log(n_employees).","code":""},{"path":"/news/index.html","id":"errorlocate-04","dir":"Changelog","previous_headings":"","what":"errorlocate 0.4","title":"errorlocate 0.4","text":"CRAN release: 2020-09-29 Implemented optimization, invalid records now treated. Can greatly enhance processing time! Thanks Jos de Waard. Fixed issue #21, thanks Sander Scholtus: strict equalities Fixed issue #22, thanks Sander Scholtus: missing columns data. Fixed issue #23, “ ==”” FALSE clause handled incorrectly.","code":""},{"path":"/news/index.html","id":"errorlocate-030","dir":"Changelog","previous_headings":"","what":"errorlocate 0.3.0","title":"errorlocate 0.3.0","text":"CRAN release: 2020-02-06 Fixed issue #19 #20: rules now may contain var_group assignments Fixed issue soft constraints: type variables sometimes incorrect Parsing statements 2 expressions condition now improved","code":""},{"path":"/news/index.html","id":"errorlocate-020","dir":"Changelog","previous_headings":"","what":"errorlocate 0.2.0","title":"errorlocate 0.2.0","text":"CRAN release: 2019-07-01 Fixed issue #17: -rules may contain linear equality.","code":""}]
